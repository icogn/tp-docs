"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[157],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>h});var n=a(7294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var o=n.createContext({}),u=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=u(t.components);return n.createElement(o.Provider,{value:e},t.children)},d="mdxType",s={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,o=t.parentName,m=p(t,["components","mdxType","originalType","parentName"]),d=u(a),k=l,h=d["".concat(o,".").concat(k)]||d[k]||s[k]||r;return a?n.createElement(h,i(i({ref:e},m),{},{components:a})):n.createElement(h,i({ref:e},m))}));function h(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=k;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=t,p[d]="string"==typeof t?t:l,i[1]=p;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},2328:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>u,contentTitle:()=>p,default:()=>s,frontMatter:()=>i,metadata:()=>o,toc:()=>m});var n=a(7462),l=(a(7294),a(3905)),r=a(9960);const i={},p="Rando SeedInfo ARCP Structure Proposal",o={unversionedId:"technical-explanations/rando-seedInfo-arcp-proposal",id:"technical-explanations/rando-seedInfo-arcp-proposal",title:"Rando SeedInfo ARCP Structure Proposal",description:"This page describes an alternative way of storing ARC patching instructions in a TPRando seed GCI.",source:"@site/docs/technical-explanations/rando-seedInfo-arcp-proposal.mdx",sourceDirName:"technical-explanations",slug:"/technical-explanations/rando-seedInfo-arcp-proposal",permalink:"/tp-docs/docs/technical-explanations/rando-seedInfo-arcp-proposal",draft:!1,editUrl:"https://github.com/icogn/tp-docs/edit/main/website/docs/technical-explanations/rando-seedInfo-arcp-proposal.mdx",tags:[],version:"current",frontMatter:{},sidebar:"technicalExplanations",previous:{title:"Rando Seed Versioning",permalink:"/tp-docs/docs/technical-explanations/rando-seed-versioning"},next:{title:"Rando SeedInfo CLR0 Structure",permalink:"/tp-docs/docs/technical-explanations/rando-seedInfo-clr0"}},u={},m=[{value:"Motivation",id:"motivation",level:2},{value:"Benefits",id:"benefits",level:2},{value:"Trade-offs",id:"trade-offs",level:3},{value:"At a high level",id:"at-a-high-level",level:2},{value:"The problem",id:"the-problem",level:3},{value:"Current structure",id:"current-structure",level:2},{value:"Problems with the current stucture",id:"problems-with-the-current-stucture",level:3},{value:"How to improve",id:"how-to-improve",level:3},{value:"Solution",id:"solution",level:4},{value:"Tree Structure",id:"tree-structure",level:2},{value:"Building the structure",id:"building-the-structure",level:3},{value:"Patches",id:"patches",level:2},{value:"Generating the RuntimeTable",id:"generating-the-runtimetable",level:2},{value:"DirInfoTable",id:"dirinfotable",level:2},{value:"Patches Part 2",id:"patches-part-2",level:2},{value:"Patch offset",id:"patch-offset",level:3},{value:"Patch contents",id:"patch-contents",level:3},{value:"Patch contents extended",id:"patch-contents-extended",level:3},{value:"Patch Content Optimization",id:"patch-content-optimization",level:3},{value:"Special String Values",id:"special-string-values",level:2},{value:"Header",id:"header",level:2},{value:"Structure Definition",id:"structure-definition",level:2},{value:"Structures in GCI",id:"structures-in-gci",level:3},{value:"Generated Structures",id:"generated-structures",level:3},{value:"Other thoughts",id:"other-thoughts",level:2}],d={toc:m};function s(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"rando-seedinfo-arcp-structure-proposal"},"Rando SeedInfo ARCP Structure Proposal"),(0,l.kt)("p",null,"This page describes an alternative way of storing ARC patching instructions in a TPRando seed GCI."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Note: You will see this section of the seed GCI referred to as the ",(0,l.kt)("inlineCode",{parentName:"em"},"ARCP")," section (for arc patching).",(0,l.kt)("br",null),"\nThis naming is inspired by what you already see in the game files, such as ",(0,l.kt)("inlineCode",{parentName:"em"},"RARC"),", ",(0,l.kt)("inlineCode",{parentName:"em"},"J3D2"),", ",(0,l.kt)("inlineCode",{parentName:"em"},"BMDR"),", etc.")),(0,l.kt)("h2",{id:"motivation"},"Motivation"),(0,l.kt)("p",null,"A smaller GCI is generally more desirable than a large one, but the GCI's block count is especially important for console players."),(0,l.kt)("p",null,"If a user is putting 10 seed GCIs on their memory card as advertised, increases in block size are multiplied by 10."),(0,l.kt)("p",null,"That is to say, an increase in block size from 3 to 4 is more like changing from 30 to 40.\nLikewise, shaving off a block from the size is more like shaving off 10 blocks."),(0,l.kt)("p",null,"So it is reasonable to shave off blocks from the size if we are able to."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"(This is why I think there should be an option to generate seed GCIs which leave out the image data.)")),(0,l.kt)("h2",{id:"benefits"},"Benefits"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"With the current data of 332 patches (288 items and 44 message indexes), we cut the Arc Patch section of the seed GCI down to approximately 27% of its current size (from 0x2980 bytes to 0xB40).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The will allow Seed GCIs to likely be reduced to a single block (not counting the imageData/comments block)."))),(0,l.kt)("li",{parentName:"ul"},"Only do as many ",(0,l.kt)("inlineCode",{parentName:"li"},"my_DVDConvertPathToEntrynum")," calls as absolutely necessary instead of one per patch.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This goes from 332 calls to roughly 124."))),(0,l.kt)("li",{parentName:"ul"},"Instead of scanning through every patch every time you might want to apply one, simply scan by ",(0,l.kt)("inlineCode",{parentName:"li"},"entryNum")," then immediately apply all patches once/if you find a match."),(0,l.kt)("li",{parentName:"ul"},"Supports patching arcs in ways more complex than simply 1, 2, or 4 bytes.")),(0,l.kt)("h3",{id:"trade-offs"},"Trade-offs"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Need to generate the arc ",(0,l.kt)("inlineCode",{parentName:"li"},"entryNum")," lookup table at runtime (only do this once).")),(0,l.kt)("h2",{id:"at-a-high-level"},"At a high level"),(0,l.kt)("p",null,'When "arcA" is loaded, we check if this arc needs to be patched.\nIf it does, we apply the appropriate patches.'),(0,l.kt)("p",null,"This means that we need a list of arc identifiers, with each entry mapping to a list of patches to apply:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcsToPatch => ","[arcA, arcD, arcQ, arc7, arcC, arc2, ...]")),(0,l.kt)("p",null,"Within the list, each arc must map to a list of patches:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcA => ","[patch0, patch1, patch2, ...]")),(0,l.kt)("h3",{id:"the-problem"},"The problem"),(0,l.kt)("p",null,"This would be simple enough, but the problem is that we must wait until runtime to generate the arc identifiers."),(0,l.kt)("p",null,"For example:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We want to patch ",(0,l.kt)("inlineCode",{parentName:"li"},"/res/Stage/D_MN10/R00_00.arc"),"."),(0,l.kt)("li",{parentName:"ul"},"At runtime, we are notified that arc ",(0,l.kt)("inlineCode",{parentName:"li"},"000005AC")," was just loaded."),(0,l.kt)("li",{parentName:"ul"},"We scratch our head, because we only know the string path of the arc, not its runtime identifier.")),(0,l.kt)("p",null,"In other words, we need this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcsToPatch => ","[arcA, arcD, ...]"),(0,l.kt)("li",{parentName:"ul"},"arcA => ","[patch0, patch1, patch2, ...]")),(0,l.kt)("p",null,"but we have this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcsToPatch => ","['/res/Stage/D_MN10/R00_00.arc', '/res/Stage/D_MN01/R03_00.arc', ...]"),(0,l.kt)("li",{parentName:"ul"},"'/res/Stage/D_MN10/R00_00.arc' => ","[patch0, patch1, patch2, ...]")),(0,l.kt)("p",null,"Fortunately, the game uses a function to convert between the filepath and its identifier, and we can use this as well."),(0,l.kt)("p",null,"So essentially, the complexity comes from the above conversion which must happen at runtime."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"We can document all of the path-to-identifier mappings so that we know them at compile time.\nThe problem is that if the user is playing on a modified ROM (such as tpgz), the identifiers for a given path may be different.")),(0,l.kt)("h2",{id:"current-structure"},"Current structure"),(0,l.kt)("p",null,"The current approach is fairly straightforward."),(0,l.kt)("p",null,"We store an array which contains one entry for each patch."),(0,l.kt)("p",null,"Each entry specifies:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the arc's filepath"),(0,l.kt)("li",{parentName:"ul"},"where to apply the patch"),(0,l.kt)("li",{parentName:"ul"},"the patch data to apply")),(0,l.kt)("p",null,"Size is 0x20 bytes."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},"The offset of the byte where the item is stored from the start of the file.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"arcFileIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"The index of the file that contains the check.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x08"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"replacementValue"),(0,l.kt)("td",{parentName:"tr",align:null},"Used to be item (byte), but can be more now.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0xC"),(0,l.kt)("td",{parentName:"tr",align:null},"char","[0x12]"),(0,l.kt)("td",{parentName:"tr",align:null},"fileName"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the file where the check is stored.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1E"),(0,l.kt)("td",{parentName:"tr",align:null},"u8 (enum)"),(0,l.kt)("td",{parentName:"tr",align:null},"fileDirectoryType"),(0,l.kt)("td",{parentName:"tr",align:null},"The type of directory where the check is stored.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1F"),(0,l.kt)("td",{parentName:"tr",align:null},"u8 (enum)"),(0,l.kt)("td",{parentName:"tr",align:null},"replacementType"),(0,l.kt)("td",{parentName:"tr",align:null},"The type of replacement that is taking place.")))),(0,l.kt)("p",null,"Here is an example:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},"0x8450C")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"arcFileIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"(Placeholder space which is filled at runtime by entryNum of arc file)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x08"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"replacementValue"),(0,l.kt)("td",{parentName:"tr",align:null},"0x42 (Ball and Chain itemId)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0xC"),(0,l.kt)("td",{parentName:"tr",align:null},"char","[0x12]"),(0,l.kt)("td",{parentName:"tr",align:null},"fileName"),(0,l.kt)("td",{parentName:"tr",align:null},'"D_MN11/R00_00.arc"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1E"),(0,l.kt)("td",{parentName:"tr",align:null},"u8 (enum)"),(0,l.kt)("td",{parentName:"tr",align:null},"fileDirectoryType"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0 (Stage)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1F"),(0,l.kt)("td",{parentName:"tr",align:null},"u8 (enum)"),(0,l.kt)("td",{parentName:"tr",align:null},"replacementType"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0 (Item)")))),(0,l.kt)("h3",{id:"problems-with-the-current-stucture"},"Problems with the current stucture"),(0,l.kt)("p",null,"The main problem is the amount of space this takes up."),(0,l.kt)("p",null,"The expected patch count is currently 332."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"0x20 bytes per patch ","*"," 332 patches => 0x2980 bytes")),(0,l.kt)("p",null,"Yikes!\nA block is only 0x2000 bytes, so we are using more than a block for this portion of the seed data alone.\nSurely we can do better."),(0,l.kt)("h3",{id:"how-to-improve"},"How to improve"),(0,l.kt)("p",null,"The most obvious thing to look at is the ",(0,l.kt)("inlineCode",{parentName:"p"},"fileName"),", which takes up 0x12 bytes per patch.\nRemember, the patch is only 0x20 bytes long, so this means each seed would have 0x1758 bytes (1.5 blocks!) of the following:"),(0,l.kt)("p",null,'"D_MN11/R00_00.arc","D_MN11/R00_00.arc","D_MN11/R00_00.arc","D_MN11/R00_01.arc","D_MN11/R00_02.arc",...'),(0,l.kt)("p",null,"And yes, you would have several copies of the same string if you needed to do multiple patches to the same arc."),(0,l.kt)("h4",{id:"solution"},"Solution"),(0,l.kt)("p",null,"Rather than looking at each patch and asking which ARC it affects, we can instead look at a given ARC and determine its patches.\nSo instead of having one string per patch, we could have many patches which are pointed to by one string (generally speaking)."),(0,l.kt)("p",null,"Essentially, this means changing the structure to be more like a hierarchy/tree."),(0,l.kt)("h2",{id:"tree-structure"},"Tree Structure"),(0,l.kt)("p",null,"Example high-level representation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{\n  res: {\n    Stage: {\n      D_MN01: {\n        R00_00: { patches: [] },\n        R01_00: { patches: [] },\n        R03_00: { patches: [] },\n        R05_00: { patches: [] },\n        R06_00: { patches: [] },\n        R07_00: { patches: [] },\n        R08_00: { patches: [] },\n        R09_00: { patches: [] },\n        R10_00: { patches: [] },\n        R11_00: { patches: [] },\n        R12_00: { patches: [] },\n        R13_00: { patches: [] },\n      },\n      D_MN01B: {\n        R51_00: { patches: [] },\n      },\n      D_MN04: {\n        R01_00: { patches: [] },\n        R03_00: { patches: [] },\n        R04_00: { patches: [] },\n        R06_00: { patches: [] },\n        R07_00: { patches: [] },\n        R09_00: { patches: [] },\n        R11_00: { patches: [] },\n        R14_00: { patches: [] },\n        R16_00: { patches: [] },\n        R17_00: { patches: [] },\n      },\n      D_MN05: {\n        R00_00: { patches: [] },\n        R01_00: { patches: [] },\n        R02_00: { patches: [] },\n        R03_00: { patches: [] },\n        R05_00: { patches: [] },\n        R09_00: { patches: [] },\n        R10_00: { patches: [] },\n        R11_00: { patches: [] },\n        R22_00: { patches: [] },\n      },\n      // ...\n    },\n  },\n}\n")),(0,l.kt)("admonition",{type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"That looks an awful lot like the game's directory structure.")),(0,l.kt)("p",null,"Describing the tree will have some overhead, but we will be eliminating a ton of wasteful string data, so we will have plenty of space to work with."),(0,l.kt)("h3",{id:"building-the-structure"},"Building the structure"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We can treat each directory and file as a node.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The nodes themeselves can be stored in an array."))),(0,l.kt)("li",{parentName:"ul"},"We need to be able to look at a node and determine if it is a file or a directory."),(0,l.kt)("li",{parentName:"ul"},"If the node is a directory, we need to be able to find its children."),(0,l.kt)("li",{parentName:"ul"},"If the node is a file, we need to be able to find its patches."),(0,l.kt)("li",{parentName:"ul"},"We need to be able to determine the string name of each node.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'For example, "res" => "Stage" => "D_MN01"')))),(0,l.kt)("p",null,"Let us define a node structure at a high-level:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},'Something like "res" or "D_MN05".')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"Is this a directory or a file?")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"children"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) Child nodes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patches"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Patches for this (arc) file.")))),(0,l.kt)("p",null,"This is a little too abstract and needs to be broken down."),(0,l.kt)("p",null,"First, let's learn from the ",(0,l.kt)(r.Z,{to:"https://wiki.cloudmodding.com/tww/ARC",mdxType:"Link"},"RARC structure")," and use a string table."),(0,l.kt)("p",null,"We will end up with something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"72 65 73 00 53 74 61 67 65 00 44 5F 4D 4E 30 35  res.Stage.D_MN05\n00 44 5F 4D 4E 30 34 00 44 5F 4D 4E 30 31 00 44  .D_MN04.D_MN01.D\n5F 4D 4E 30 31 42 00 44 5F 4D 4E 31 30 00 44 5F  _MN01B.D_MN10.D_\n4D 4E 31 30 42 00 44 5F 4D 4E 31 31 00 44 5F 4D  MN10B.D_MN11.D_M\n4E 31 31 42 00 44 5F 4D 4E 30 36 00 44 5F 4D 4E  N11B.D_MN06.D_MN\n30 36 42 00 44 5F 4D 4E 30 37 00 44 5F 4D 4E 30  06B.D_MN07.D_MN0\n37 42 00 44 5F 4D 4E 30 38 00 44 5F 4D 4E 30 39  7B.D_MN08.D_MN09\n00 52 5F 53 50 30 31 00 44 5F 53 42 31 30 00 46  .R_SP01.D_SB10.F\n5F 53 50 31 30 38 00 52 5F 53 50 31 30 39 00 46  _SP108.R_SP109.F\n5F 53 50 31 32 31 00 46 5F 53 50 31 30 39 00 46  _SP121.F_SP109.F\n5F 53 50 31 31 31 00 46 5F 53 50 31 31 33 00 44  _SP111.F_SP113.D\n5F 53 42 30 33 00 46 5F 53 50 31 31 35 00 46 5F  _SB03.F_SP115.F_\n53 50 31 31 30 00 44 5F 53 42 30 32 00 46 5F 53  SP110.D_SB02.F_S\n50 31 32 32 00 46 5F 53 50 31 32 34 00 44 5F 53  P122.F_SP124.D_S\n42 30 34 00 46 5F 53 50 31 31 38 00 46 5F 53 50  B04.F_SP118.F_SP\n31 31 34 00 44 5F 53 42 30 30 00 46 5F 53 50 31  114.D_SB00.F_SP1\n31 37 00 46 5F 53 50 31 31 36 00 62 6D 67 72 65  17.F_SP116.bmgre\n73 35 00 62 6D 67 72 65 73 31 00 62 6D 67 72 65  s5.bmgres1.bmgre\n73 36 00 62 6D 67 72 65 73 34 00 62 6D 67 72 65  s6.bmgres4.bmgre\n73 32 00 62 6D 67 72 65 73 38 00 62 6D 67 72 65  s2.bmgres8.bmgre\n73 37 00 52 32 32 5F 30 30 00 52 30 30 5F 30 30  s7.R22_00.R00_00\n00 52 30 39 5F 30 30 00 52 30 32 5F 30 30 00 52  .R09_00.R02_00.R\n30 35 5F 30 30 00 52 30 33 5F 30 30 00 52 30 31  05_00.R03_00.R01\n5F 30 30 00 52 31 30 5F 30 30 00 52 31 31 5F 30  _00.R10_00.R11_0\n30 00 52 31 34 5F 30 30 00 52 30 34 5F 30 30 00  0.R14_00.R04_00.\n52 30 36 5F 30 30 00 52 30 37 5F 30 30 00 52 31  R06_00.R07_00.R1\n37 5F 30 30 00 52 31 36 5F 30 30 00 52 30 38 5F  7_00.R16_00.R08_\n30 30 00 52 31 32 5F 30 30 00 52 31 33 5F 30 30  00.R12_00.R13_00\n00 52 35 31 5F 30 30 00 52 31 35 5F 30 30 00 00  .R51_00.R15_00..\n")),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},'Notice that we only need one copy of "R01_00" even though it is used in D_MN01, D_MN04, D_MN05, and I\'m sure plenty of others.')),(0,l.kt)("p",null,"Revisiting the structure"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("em",{parentName:"strong"},"strTableOffset"))),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset in string table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"Is this a directory or a file?")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"children"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) Child nodes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patches"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Patches for this (arc) file.")))),(0,l.kt)("p",null,'Let\'s look at "patches" now.'),(0,l.kt)("p",null,"A node can have an arbitrary number of patches, so let's go ahead and pull that out into its own table."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset in string table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"Is this a directory or a file?")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"children"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) Child nodes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("em",{parentName:"strong"},"patchTableIndex"))),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Patches for this (arc) file.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("em",{parentName:"strong"},"numPatches"))),(0,l.kt)("td",{parentName:"tr",align:null},"u8?"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Number of patches for this (arc) file.")))),(0,l.kt)("p",null,'Let\'s look at "children" now.'),(0,l.kt)("p",null,"A child is a Node, and we already have a table for this.\nIn fact, this structure we are describing is an entry in that table."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset in string table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"?"),(0,l.kt)("td",{parentName:"tr",align:null},"Is this a directory or a file?")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("em",{parentName:"strong"},"nodeTableIndex"))),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) Index of first child node.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("em",{parentName:"strong"},"numChildren"))),(0,l.kt)("td",{parentName:"tr",align:null},"u8?"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) Number of Child nodes.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchTableIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"u16?"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Patches for this (arc) file.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"u8?"),(0,l.kt)("td",{parentName:"tr",align:null},"(file only) Number of patches for this (arc) file.")))),(0,l.kt)("p",null,"Let's see how much room this takes up:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"15 bits (10 is actually plenty here)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nodeTableIndex or patchTableIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numChildren or numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")))),(0,l.kt)("p",null,"This takes up 5 bytes, which we can round up to 8.\nIf we can get this down to 4 bytes, the space we need for the node table will be cut in half."),(0,l.kt)("p",null,"We'll come back to this."),(0,l.kt)("h2",{id:"patches"},"Patches"),(0,l.kt)("p",null,"When the ARC file is loaded, its path such as ",(0,l.kt)("inlineCode",{parentName:"p"},"/res/Stage/D_MN01/R01_00.arc")," is converted to a u32 id called ",(0,l.kt)("inlineCode",{parentName:"p"},"entryNum"),"."),(0,l.kt)("p",null,"Let's imagine we have a table which we will refer to as the RuntimeTable containing entries like the following:",(0,l.kt)("br",null),"\n",(0,l.kt)("em",{parentName:"p"},"(A better table name will be at end of this article once I come up with one.)")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"entryNum"),(0,l.kt)("td",{parentName:"tr",align:null},"u32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchTableIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")))),(0,l.kt)("p",null,"Whenever an ARC is loaded, we can look at its ",(0,l.kt)("inlineCode",{parentName:"p"},"entryNum")," then scan the above table.\nIf we find a match, we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"patchTableIndex")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"numPatches")," alongside the patch table itself to handle applying the appropriate patches."),(0,l.kt)("p",null,"Ideally, the only data we would have in the seed GCI's ARC patch section are the above RuntimeTable and the patch table.\nUnfortunately, we must wait until runtime to accurately convert filepaths to entryNums."),(0,l.kt)("p",null,"Let's look at the chunks we have mentioned so far:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Needed when?"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"nodeTable"),(0,l.kt)("td",{parentName:"tr",align:null},"Not needed after creating runtimeTable")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"stringTable"),(0,l.kt)("td",{parentName:"tr",align:null},"Not needed after creating runtimeTable")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchTable"),(0,l.kt)("td",{parentName:"tr",align:null},"Needed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"runtimeTable"),(0,l.kt)("td",{parentName:"tr",align:null},"Generated at runtime")))),(0,l.kt)("h2",{id:"generating-the-runtimetable"},"Generating the RuntimeTable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{\n  res: {\n    Stage: {\n      D_MN01: {\n        R11_00: { patches: [] },\n        R12_00: { patches: [] },\n        R13_00: { patches: [] },\n      },\n      D_MN01B: {\n        R51_00: { patches: [] },\n      },\n      D_MN04: {\n        R01_00: { patches: [] },\n        R03_00: { patches: [] },\n        R04_00: { patches: [] },\n      },\n    },\n  },\n},\n")),(0,l.kt)("p",null,"Let's pretend the above represents the ARCs which we want to patch."),(0,l.kt)("p",null,"To generate the runtimeTable, we need to navigate through the tree and convert each File node into the following:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"entryNum"),(0,l.kt)("td",{parentName:"tr",align:null},"u32")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchTableIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")))),(0,l.kt)("p",null,"I'm going to keep track of a variable called ",(0,l.kt)("inlineCode",{parentName:"p"},"currentPatchIndex")," to make a point later."),(0,l.kt)("p",null,"Here is how that (depth-first) traversal would look:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," is 0."),(0,l.kt)("li",{parentName:"ul"},"At root. Not a file. numChildren is 1."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"res"),". Not a file. numChildren is 1."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"Stage"),". Not a file. numChildren is 3."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN01"),". Not a file. numChildren is 3."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R11_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 0. Copy into RuntimeTableEntry0."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 1. Copy into RuntimeTableEntry0."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (1).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 1."))))),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R12_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 1. Copy into RuntimeTableEntry1."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 3. Copy into RuntimeTableEntry1."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (3).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 4."))))),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R13_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 4. Copy into RuntimeTableEntry2."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 1. Copy into RuntimeTableEntry2."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (1).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 5."))))),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry in ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN01"),", so will go to next child of ",(0,l.kt)("inlineCode",{parentName:"li"},"Stage"),")"),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN01B"),". Not a file. numChildren is 1."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R51_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 5. Copy into RuntimeTableEntry3."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 2. Copy into RuntimeTableEntry3."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (2).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 7."))))),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry in ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN01B"),", so will go to next child of ",(0,l.kt)("inlineCode",{parentName:"li"},"Stage"),")"),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN04"),". Not a file. numChildren is 3."),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R01_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 7. Copy into RuntimeTableEntry4."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 4. Copy into RuntimeTableEntry4."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (4).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 11."))))),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R03_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 11. Copy into RuntimeTableEntry5."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 1. Copy into RuntimeTableEntry5."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (1).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 12."))))),(0,l.kt)("li",{parentName:"ul"},"At ",(0,l.kt)("inlineCode",{parentName:"li"},"R04_00"),". Is a file.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," property are both 12. Copy into RuntimeTableEntry6."),(0,l.kt)("li",{parentName:"ul"},"the node's ",(0,l.kt)("inlineCode",{parentName:"li"},"numPatches")," property is 1. Copy into RuntimeTableEntry6."),(0,l.kt)("li",{parentName:"ul"},"Increase ",(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," by the number of patches (1).",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," becomes 13."))))),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry in ",(0,l.kt)("inlineCode",{parentName:"li"},"D_MN04"),")"),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry in ",(0,l.kt)("inlineCode",{parentName:"li"},"Stage"),")"),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry in ",(0,l.kt)("inlineCode",{parentName:"li"},"res"),")"),(0,l.kt)("li",{parentName:"ul"},"(That was the last entry of the root)"),(0,l.kt)("li",{parentName:"ul"},"We are done.")),(0,l.kt)("p",null,"The key takeaways are the following:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"The traversal is deterministic (will always be done in the same order)."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"currentPatchIndex")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"patchTableOffset")," are equal every step of the way.")),(0,l.kt)("p",null,"Thus we can conclude:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We do not need to store the patchTableOffset in the node data.")),(0,l.kt)("p",null,"Let's look at what a Node might look like now:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"15 bits (10 is actually plenty here)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"firstChildNodeIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"(directory only) u16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numChildren or numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the case of a File, we only need 24 bits."),(0,l.kt)("li",{parentName:"ul"},"In the case of a Directory, we need 40 bits.")),(0,l.kt)("p",null,"If we can get it down to <= 32 bits in the case of a Directory, then we can cut the nodeTable size in half."),(0,l.kt)("h2",{id:"dirinfotable"},"DirInfoTable"),(0,l.kt)("p",null,"Here is something we can do:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Create another table called ",(0,l.kt)("inlineCode",{parentName:"li"},"dirInfoTable")," which has entries like the following:")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"firstChildNodeIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"numChildren"),(0,l.kt)("td",{parentName:"tr",align:null},"u16")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Then change Node to look like this:")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"15 bits (10 is actually plenty here)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dirInfoIndex (dir) or numPatches (file)"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")))),(0,l.kt)("p",null,"We have pulled out the data which is only needed for the Directory nodes into their own table.\nThere is only one entry for a directory node, and 0 for a file node.\nSince the majority of our nodes are files, this saves quite a bit of space."),(0,l.kt)("p",null,"So now both the File node and Directory node only need 24 bytes."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"We can store ",(0,l.kt)("inlineCode",{parentName:"p"},"dirInfoIndex")," as a u8 because there is a maximum of 90 directory nodes in the game based on the exhaustive list of arc files which is well under the 255 max for a u8."),(0,l.kt)("p",{parentName:"admonition"},"Probably won't be doing anywhere close to 255 patches on an individual arc, so u8 for ",(0,l.kt)("inlineCode",{parentName:"p"},"numPatches")," should be fine as well.")),(0,l.kt)("p",null,"But we can do even better."),(0,l.kt)("p",null,"Storing this as 3 bytes would force us to round up to 4, but we can store it in 2 arrays so that we only use 3 bytes while still having the data nicely aligned."),(0,l.kt)("p",null,"First array will contain NodeInfoA (size: 2 bytes):"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Reserved bits (more on this later)"),(0,l.kt)("td",{parentName:"tr",align:null},"3 bits")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"12 bits")))),(0,l.kt)("p",null,"Second array will contain NodeInfoB (size: 1 byte):"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dirInfoIndex (dir) or numPatches (file)"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")))),(0,l.kt)("p",null,"At this point, we have all of the pieces we need to describe the following:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcsToPatch => ","[arcA, arcD, arcQ, arc7, arcC, arc2, ...]")),(0,l.kt)("p",null,"Now we just need to go discuss this part:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"arcA => ","[patch0, patch1, patch2, ...]")),(0,l.kt)("h2",{id:"patches-part-2"},"Patches Part 2"),(0,l.kt)("p",null,"A patch is made up of the following information:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Where should we overwrite bytes"),(0,l.kt)("li",{parentName:"ul"},"What value should we write there")),(0,l.kt)("h3",{id:"patch-offset"},"Patch offset"),(0,l.kt)("p",null,"The largest arc file is ",(0,l.kt)("inlineCode",{parentName:"p"},"/res/Object/Demo28_01.arc")," which is 3603200 bytes when uncompressed, or 0x0036FB00."),(0,l.kt)("p",null,"This means 3 bytes will always be enough to specify the offset at which we will write the patch."),(0,l.kt)("h3",{id:"patch-contents"},"Patch contents"),(0,l.kt)("p",null,"The first thing to note is that the patch we want to write could be 1, 2, or 4 bytes, so we will need a way to specify how many bytes we should write."),(0,l.kt)("p",null,"Let's use a u8 enum for this."),(0,l.kt)("p",null,"Here is what we have so far:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchType"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},"3 bytes")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Remaining space"),(0,l.kt)("td",{parentName:"tr",align:null},"4 bytes")))),(0,l.kt)("p",null,"We can use the patchType enum to specify what is in the remaining space."),(0,l.kt)("p",null,"For example, if we needed to patch an itemId which is 1 byte, we could have something like the following:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[00 05 E6 EC 00 00 00 45]")),(0,l.kt)("p",null,"meaning:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"patchType: 0 (ItemId)"),(0,l.kt)("li",{parentName:"ul"},"offset: 0x05E6EC"),(0,l.kt)("li",{parentName:"ul"},"value: 0x45 (",(0,l.kt)("inlineCode",{parentName:"li"},"patchType")," indicates that the value is 1 byte)")),(0,l.kt)("p",null,"Example 2:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[01 02 FB 6C 00 00 AB CD]")),(0,l.kt)("p",null,"meaning:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"patchType: 1 (ItemMessage)"),(0,l.kt)("li",{parentName:"ul"},"offset: 0x02FB6C"),(0,l.kt)("li",{parentName:"ul"},"value: 0xABCD (",(0,l.kt)("inlineCode",{parentName:"li"},"patchType")," indicates that the value is 2 bytes)")),(0,l.kt)("p",null,"If we have a type of patch that only needs to write 1, 2, 3, or 4 bytes, we can fit that into the remaining space."),(0,l.kt)("p",null,"But what if we want to write more than 4 bytes?"),(0,l.kt)("h3",{id:"patch-contents-extended"},"Patch contents extended"),(0,l.kt)("p",null,"Let's create another chunk and call it patchExtensions.\nIt is a stream of bytes which contains data for patches that are too big to fit into the 2nd half of the patch."),(0,l.kt)("p",null,"A patch's ",(0,l.kt)("inlineCode",{parentName:"p"},"patchType")," will indicate if a patch uses the patchExtensions chunk."),(0,l.kt)("p",null,"For example:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[AB 01 A6 6F 01 23 00 0C]")),(0,l.kt)("p",null,"meaning:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"patchType: 0xAB (LongPatch) (enum value was chosen arbitrarily)"),(0,l.kt)("li",{parentName:"ul"},"offset: 0x01A66F"),(0,l.kt)("li",{parentName:"ul"},"patchExtensionsOffset: 0x0123"),(0,l.kt)("li",{parentName:"ul"},"patchBytelength: 0x000C")),(0,l.kt)("p",null,"Notice that the 2nd group of 4 bytes has a completely different meaning than before.\nThat is the power of using the ",(0,l.kt)("inlineCode",{parentName:"p"},"patchType")," enum -- the remaining 4 bytes can be interpreted according to the value of the enum."),(0,l.kt)("p",null,"The patchExtensions chunk is a stream of bytes, so according to the above Patch, we should start at byte 0x123 in the extensions chunk and copy 0xC bytes into the arc data starting at offset 0x01A66F."),(0,l.kt)("p",null,"Here is an example of another kind of patch you might use:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[CD 0B FA E0 00 F3 00 FF]")),(0,l.kt)("p",null,"meaning:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"patchType: 0xCD (LongPatchSkipBytes)"),(0,l.kt)("li",{parentName:"ul"},"offset: 0x0BFAE0"),(0,l.kt)("li",{parentName:"ul"},"patchExtensionsOffset: 0x00F3"),(0,l.kt)("li",{parentName:"ul"},"skipIfByteIs: 0xFF")),(0,l.kt)("p",null,"We didn't specify the byteLength, but let's check what the data looks like in the extensions section:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[00 08 67 FF FF 63 FF FF 12 34]")),(0,l.kt)("p",null,"Let's assume that ",(0,l.kt)("inlineCode",{parentName:"p"},"LongPatchSkipBytes")," means that the first 2 bytes in the extensions section will indicate the length."),(0,l.kt)("p",null,"In this case, the byte length is 8."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"skipIfByteIs")," is 0xFF, so we will copy the next 8 bytes, but we will skip over any bytes which have a value of 0xFF."),(0,l.kt)("p",null,"Those were just some examples.\nYou can really do whatever you want with the enum, and the good news is that you can easily add new enum types without breaking backwards compatibility."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"This extension section is just an idea.\nIt wouldn't be included until/unless we actually need it.")),(0,l.kt)("h3",{id:"patch-content-optimization"},"Patch Content Optimization"),(0,l.kt)("p",null,"Our patches currently look like the following:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchType"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},"3 bytes")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Remaining space"),(0,l.kt)("td",{parentName:"tr",align:null},"4 bytes")))),(0,l.kt)("p",null,"In terms of our current seed's ",(0,l.kt)("inlineCode",{parentName:"p"},"ARCP")," section size, these actually take up the majority of the space, so if we can improve this we will get some pretty significant gains."),(0,l.kt)("p",null,'Of our 332 patches currently, 288 only need one byte of the "Remaining space" bytes (meaning they waste 3 bytes), and the other 44 are message indexes (meaning they waste 2 bytes).'),(0,l.kt)("p",null,'Let\'s create another chunk called patchContent and write the values that we would have put in the "Remaining space" in the above table there in a back-to-back fashion.'),(0,l.kt)("p",null,"As we iterate through the patches (which are now 4 bytes long), we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"patchType")," to determine how many bytes to read from the patchContent.\nWe will keep track of our current position in patchContent (which is essentially a data stream) as we do this."),(0,l.kt)("p",null,"So patches look like this now:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"patchType"),(0,l.kt)("td",{parentName:"tr",align:null},"u8")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"offset (to apply patch in arc)"),(0,l.kt)("td",{parentName:"tr",align:null},"3 bytes")))),(0,l.kt)("h2",{id:"special-string-values"},"Special String Values"),(0,l.kt)("p",null,"Earlier we described the string table.\nThe keen eye may have noticed that it had ",(0,l.kt)("inlineCode",{parentName:"p"},"bmgres4")," in it, but nothing like ",(0,l.kt)("inlineCode",{parentName:"p"},"Msgus"),"."),(0,l.kt)("p",null,"This is because the exact name that should be used in place of ",(0,l.kt)("inlineCode",{parentName:"p"},"Msgus")," depends on the TP region you are playing (US, PAL, JP) and will be filled in at runtime by the Randomizer."),(0,l.kt)("p",null,"We can use a bit in the NodeA entry to indicate that it is a string enum and not a value in the string table as follows:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isDir"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"isStringEnum"),(0,l.kt)("td",{parentName:"tr",align:null},"1 bit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Reserved bits (more on this later)"),(0,l.kt)("td",{parentName:"tr",align:null},"2 bits")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset or stringEnum"),(0,l.kt)("td",{parentName:"tr",align:null},"12 bits")))),(0,l.kt)("p",null,"So for example:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[80 05]")," is a directory node, and its name is stored at offset 0x5 in the string table."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"[C0 AA]")," is a directory node.\nIt uses a string enum rather than the string table, and its enum is 0xAA.\nThe Randomizer was compiled for the US version, so it knows that the value of enum 0xAA is ",(0,l.kt)("inlineCode",{parentName:"p"},"Msgus"),"."),(0,l.kt)("p",null,"That should be all of the areas we need to discuss regarding the inner structure."),(0,l.kt)("h2",{id:"header"},"Header"),(0,l.kt)("p",null,"The entire structure is split up into the chunks we discussed above, so we will use a header to indicate things like the offset to a chunk and how many entries are in it."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"char","[4]"),(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},'Always "ARCP"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"majorVersion"),(0,l.kt)("td",{parentName:"tr",align:null},"This is independent of the randomizer version")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x05"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"minorVersion"),(0,l.kt)("td",{parentName:"tr",align:null},"This is independent of the randomizer version")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x06"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"totalSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Total byte size of ARCP section")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x08"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"nodeInfoAOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to NodeInfoA table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0A"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"nodeInfoBOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to NodeInfoB table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0C"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in NodeInfoA and NodeInfoB tables")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0E"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"dirInfoOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to DirInfo table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x10"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numDirInfos"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in DirInfo table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x12"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to string table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x14"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to Patch table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x16"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in Patch table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x18"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchExtOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to PatchExtensions chunk")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x8"),(0,l.kt)("td",{parentName:"tr",align:null},"u8","[8]"),(0,l.kt)("td",{parentName:"tr",align:null},"padding/reserved"),(0,l.kt)("td",{parentName:"tr",align:null},"Currently unused, rounds header to 0x20 bytes")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'The section title of "ARCP" (short for Arc Patch) is to make it easier to visually understand what you are looking at when inspecting in a hex editor.\nThis is inspired by how many of the files are already handled in TP.\nMight be useful some other way at some point as well.\nWe also have room for it.')),(0,l.kt)("p",null,"Major version is a u8 which gets incremented every time there is a change which breaks backwards compatibility."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The benefit of storing a version number at this level rather than just at the top SeedInfo level is that the Randomizer can check the ArcPatch section's version and run the appropriate routines based off of that (if that version of the Randomizer was supporting multiple ARCP major versions at the same time, for example).")),(0,l.kt)("p",null,"Minor version number is more for debugging purposes.\nThis would be incremented whenever a non-breaking change is made, such as adding a ",(0,l.kt)("inlineCode",{parentName:"p"},"patchType")," enum or a string enum such as the one which is used for ",(0,l.kt)("inlineCode",{parentName:"p"},"Msgus"),".\nNon-breaking in the sense that version 42.4 is essentially a superset of 42.3."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Incrementing the major or minor version of the ARCP section would also increment the version number of SeedInfo as appropriate.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"totalSize is the total number of bytes of the ARCP section.\nEach chunk will be rounded to a multiple of 0x10, so this value will also always be rounded to 0x10.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"patchExtOffset will be 0x0000 if there is no patchExtensions chunk (because it is not needed).\nOr realistically it will always be 0x0000 until we actually have something that needs the extensions chunk."))),(0,l.kt)("p",null,"Now we are ready to put everything together."),(0,l.kt)("h2",{id:"structure-definition"},"Structure Definition"),(0,l.kt)("p",null,"The ARCP section will be broken into the following chunks:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Header"),(0,l.kt)("td",{parentName:"tr",align:null},"object")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NodeInfoA"),(0,l.kt)("td",{parentName:"tr",align:null},"array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NodeInfoB"),(0,l.kt)("td",{parentName:"tr",align:null},"array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DirInfo"),(0,l.kt)("td",{parentName:"tr",align:null},"array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"StrTable"),(0,l.kt)("td",{parentName:"tr",align:null},"chunk")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"PatchTable"),(0,l.kt)("td",{parentName:"tr",align:null},"array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"PatchContent"),(0,l.kt)("td",{parentName:"tr",align:null},"chunk")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"PatchExtensions"),(0,l.kt)("td",{parentName:"tr",align:null},"chunk")))),(0,l.kt)("p",null,"At runtime, this will transform into another block of data:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"source"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"RuntimeHeader"),(0,l.kt)("td",{parentName:"tr",align:null},"object"),(0,l.kt)("td",{parentName:"tr",align:null},"generated")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ArcList"),(0,l.kt)("td",{parentName:"tr",align:null},"array"),(0,l.kt)("td",{parentName:"tr",align:null},"generated")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"PatchTable"),(0,l.kt)("td",{parentName:"tr",align:null},"array"),(0,l.kt)("td",{parentName:"tr",align:null},"generated")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"PatchExtensions"),(0,l.kt)("td",{parentName:"tr",align:null},"chunk"),(0,l.kt)("td",{parentName:"tr",align:null},"copied")))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"We may not actually want to add the PatchExtensions part until/unless it becomes necessary, but we can leave space for it in the header to make it easily backwards compatible.")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"structures-in-gci"},"Structures in GCI"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Header (size: 0x20):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"char","[4]"),(0,l.kt)("td",{parentName:"tr",align:null},"offset"),(0,l.kt)("td",{parentName:"tr",align:null},'Always "ARCP"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"majorVersion"),(0,l.kt)("td",{parentName:"tr",align:null},"This is independent of the randomizer version")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x05"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"minorVersion"),(0,l.kt)("td",{parentName:"tr",align:null},"This is independent of the randomizer version")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x06"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"totalSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Total byte size of ARCP section")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x08"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numNodes"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in NodeInfoA and NodeInfoB tables")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0A"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"nodeInfoAOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to NodeInfoA table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0C"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"nodeInfoBOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to NodeInfoB table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0E"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numDirInfos"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in DirInfo table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x10"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"dirInfoOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to DirInfo table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x12"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to string table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x14"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numPatches"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of entries in Patch table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x16"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to Patch table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x18"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchContentOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to Patch content stream")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1A"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numArcs"),(0,l.kt)("td",{parentName:"tr",align:null},'Number of nodes of type "File"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1C"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchExtOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to PatchExtensions chunk (0 if unused)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x1E"),(0,l.kt)("td",{parentName:"tr",align:null},"u8","[2]"),(0,l.kt)("td",{parentName:"tr",align:null},"padding/reserved"),(0,l.kt)("td",{parentName:"tr",align:null},"Currently unused, rounds header to 0x20 bytes")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NodeInfoA (size: 0x2):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,l.kt)("td",{parentName:"tr",align:null},"isDir")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1 bit"),(0,l.kt)("td",{parentName:"tr",align:null},"isStringEnum")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2 bits"),(0,l.kt)("td",{parentName:"tr",align:null},"Reserved/unused bits")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"12 bits"),(0,l.kt)("td",{parentName:"tr",align:null},"strTableOffset (u16 & 0xFFF) or stringEnum (u16 & 0xFF)")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NodeInfoB (size: 0x1):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"dirInfoIndex (dir) or numPatches (file)")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"DirInfo (size: 0x4):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"firstChildIndex")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x2"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numChildren")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"StrTable:")),(0,l.kt)("p",null,"Back-to-back null-terminated strings."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"PatchTable (size: 0x4):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"patchType")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0 & 0x00FFFFFF"),(0,l.kt)("td",{parentName:"tr",align:null},"u32 (3 bytes)"),(0,l.kt)("td",{parentName:"tr",align:null},"offset")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"PatchContent:")),(0,l.kt)("p",null,"Stream of bytes."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"PatchExtensions:")),(0,l.kt)("p",null,"Optional chunk of bytes.\nPatches can point to data in here."),(0,l.kt)("h3",{id:"generated-structures"},"Generated Structures"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"RuntimeHeader:")),(0,l.kt)("p",null,"Not really in the scope of this article to define an exact structure for this, but it will need something to do the following:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"pointer/offset to ArcList"),(0,l.kt)("li",{parentName:"ul"},"pointer/offset to PatchTable"),(0,l.kt)("li",{parentName:"ul"},"pointer/offset to PatchExtensions"),(0,l.kt)("li",{parentName:"ul"},"way to free data")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"ArcList:")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"entryNum (returned from ",(0,l.kt)("inlineCode",{parentName:"td"},"my_DVDConvertPathToEntrynum"),")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x4"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"patchTableIndex")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x6"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"numPatches")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"PatchTable (size: 0x8):")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0"),(0,l.kt)("td",{parentName:"tr",align:null},"u8 (enum)"),(0,l.kt)("td",{parentName:"tr",align:null},"patchType")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0 & 0x00FFFFFF"),(0,l.kt)("td",{parentName:"tr",align:null},"u32 (3 bytes)"),(0,l.kt)("td",{parentName:"tr",align:null},"offset")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x4"),(0,l.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,l.kt)("td",{parentName:"tr",align:null},"remainingSpace")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"PatchExtensions:")),(0,l.kt)("p",null,"Copied directly from ARCP section.\nOptional chunk of bytes.\nPatches can point to data in here."),(0,l.kt)("h2",{id:"other-thoughts"},"Other thoughts"),(0,l.kt)("p",null,"There is another optimization which can be done.\nYou can make a change such that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[bmgres1,bmgres4,bmgres5,bmgres6,bmgres7,bmgres8]"))),(0,l.kt)("p",null,"changes to something more like:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[bmgres] => [1,4,5,6,7,8]"))),(0,l.kt)("p",null,"for this and similar strings, but this adds a lot of complexity (to generating the GCI) and saves very little space, so it is not really worth it."),(0,l.kt)("p",null,"Here is validated example data which has you can view in a hex editor:"),(0,l.kt)("p",null,(0,l.kt)("a",{target:"_blank",href:"/binData/arcpExampleData.bin"},"Download arcpExampleData.bin")))}s.isMDXComponent=!0}}]);