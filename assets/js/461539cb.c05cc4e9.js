"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3529],{3905:(t,e,n)=>{n.d(e,{Zo:()=>m,kt:()=>c});var a=n(7294);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,l=function(t,e){if(null==t)return{};var n,a,l={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(l[n]=t[n]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(l[n]=t[n])}return l}var u=a.createContext({}),s=function(t){var e=a.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},m=function(t){var e=s(t.components);return a.createElement(u.Provider,{value:e},t.children)},d="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,l=t.mdxType,r=t.originalType,u=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),d=s(n),h=l,c=d["".concat(u,".").concat(h)]||d[h]||p[h]||r;return n?a.createElement(c,i(i({ref:e},m),{},{components:n})):a.createElement(c,i({ref:e},m))}));function c(t,e){var n=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=n.length,i=new Array(r);i[0]=h;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=t,o[d]="string"==typeof t?t:l,i[1]=o;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2762:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=n(7462),l=(n(7294),n(3905));const r={},i="Rando SeedInfo CLR0 Structure",o={unversionedId:"technical-explanations/rando-seedInfo-clr0",id:"technical-explanations/rando-seedInfo-clr0",title:"Rando SeedInfo CLR0 Structure",description:"This page describes a way of storing RGB colors in the TPRando seed GCI.",source:"@site/docs/technical-explanations/rando-seedInfo-clr0.mdx",sourceDirName:"technical-explanations",slug:"/technical-explanations/rando-seedInfo-clr0",permalink:"/tp-docs/docs/technical-explanations/rando-seedInfo-clr0",draft:!1,editUrl:"https://github.com/icogn/tp-docs/edit/main/website/docs/technical-explanations/rando-seedInfo-clr0.mdx",tags:[],version:"current",frontMatter:{},sidebar:"technicalExplanations",previous:{title:"Rando SeedInfo ARCP Structure Proposal",permalink:"/tp-docs/docs/technical-explanations/rando-seedInfo-arcp-proposal"},next:{title:"Snowpeak Ruins Lock Softlock",permalink:"/tp-docs/docs/technical-explanations/sprlocksoftlock"}},u={},s=[{value:"Intro",id:"intro",level:2},{value:"Header",id:"header",level:2},{value:"Space-efficient approach",id:"space-efficient-approach",level:2},{value:"Mapping enum to rgb index",id:"mapping-enum-to-rgb-index",level:2},{value:"Check enum is enabled",id:"check-enum-is-enabled",level:2},{value:"Mapping enum to rgb index quickly",id:"mapping-enum-to-rgb-index-quickly",level:2},{value:"CLR0 structure",id:"clr0-structure",level:2},{value:"Header",id:"header-1",level:3},{value:"bitTable",id:"bittable",level:3},{value:"cummulativeSums",id:"cummulativesums",level:3},{value:"basicData",id:"basicdata",level:3},{value:"complexData",id:"complexdata",level:3},{value:"Other notes",id:"other-notes",level:2},{value:"Future splitting up of recoloring",id:"future-splitting-up-of-recoloring",level:3}],m={toc:s};function d(t){let{components:e,...n}=t;return(0,l.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"rando-seedinfo-clr0-structure"},"Rando SeedInfo CLR0 Structure"),(0,l.kt)("p",null,"This page describes a way of storing RGB colors in the TPRando seed GCI.\nThe main purpose of these colors would be for recoloring things in the game (such as tunic color)."),(0,l.kt)("h2",{id:"intro"},"Intro"),(0,l.kt)("p",null,"The simplistic approach to storing these colors would be to have an array of 4-byte structures as follows:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"isEnabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x01"),(0,l.kt)("td",{parentName:"tr",align:null},"u8","[3]"),(0,l.kt)("td",{parentName:"tr",align:null},"RGB")))),(0,l.kt)("p",null,"Each thing you want to recolor would be represented by an enum such as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{\n    Tunic: 0,\n    ZoraArmorPrimary: 1,\n    ZoraArmorSecondary: 2,\n    ZoraArmorHelmet: 3,\n    OrdonShield: 4,\n}\n")),(0,l.kt)("p",null,"You would then have an array of the 4-byte structures such that the index in the array is the enum."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Example byte array\n[\n    TunicEnabled,\n    TunicR,\n    TunicG,\n    TunicB,\n    ZoraArmorPrimaryEnabled,\n    ZoraArmorPrimaryR,\n    ZoraArmorPrimaryG,\n    ZoraArmorPrimaryB,\n    ...\n]\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ZoraArmorPrimary")," has a value of 1, so we would look at offset 1 in the array (starts at byte 0x04 since each structure is 4 bytes)."),(0,l.kt)("p",null,"With this approach, the size of the CLR0 structure would be 4 bytes ","*"," numberOfSupportedEnums."),(0,l.kt)("p",null,"In order to future-proof and in order to simultaneously support a more space-efficient design, we will want a header."),(0,l.kt)("h2",{id:"header"},"Header"),(0,l.kt)("p",null,"This chunk in the seed data is named CLR0."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"CLR"),' is short for "color", and the 0 is essentially the version number.'),(0,l.kt)("p",null,"This follows the scheme that is used by pretty much every file in the game (that is, sections start with a 4-char label)."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Adding to the example from before, the byte array would look like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'// Example byte array\n[\n    "C",\n    "L",\n    "R",\n    "0",\n    HeaderOffset_0x04,\n    HeaderOffset_0x05,\n    HeaderOffset_0x06,\n    HeaderOffset_0x07,\n    HeaderOffset_0x08,\n    HeaderOffset_0x09,\n    HeaderOffset_0x0a,\n    HeaderOffset_0x0b,\n    HeaderOffset_0x0c,\n    HeaderOffset_0x0d,\n    HeaderOffset_0x0e,\n    HeaderOffset_0x0f,\n    TunicEnabled,\n    TunicR,\n    TunicG,\n    TunicB,\n    ZoraArmorPrimaryEnabled,\n    ZoraArmorPrimaryR,\n    ZoraArmorPrimaryG,\n    ZoraArmorPrimaryB,\n    ...\n]\n')),(0,l.kt)("h2",{id:"space-efficient-approach"},"Space-efficient approach"),(0,l.kt)("p",null,"The above works well if you only need to store a few colors.\nBut what if we need to be able to store 75 colors?"),(0,l.kt)("p",null,"This is not that farfetched when you consider that the Midna color customizations contain 7 distinct RGB values, and the Zora Armor contains 3."),(0,l.kt)("p",null,"Also consider the case in which we support 75 recoloring options, but the player decided the only thing they want to recolor is the tunic (which takes 1 RGB value).\nWith the simplistic approach, we would have approximately 74 ","*"," 4 bytes of wasted data (296 or 0x128 bytes which is nearly 4% of a block)."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Instead of including an array entry for every single enum, we would ideally only include entries for enums we are actually using.\nThen if the player only needed 2 colors, we would only need 6 bytes of RGB data instead of 3 ","*"," 75 bytes."),(0,l.kt)("p",null,"The problem then becomes how do we map an enum to its index in the RGB array (previously the enum and its index were always identical)."),(0,l.kt)("h2",{id:"mapping-enum-to-rgb-index"},"Mapping enum to rgb index"),(0,l.kt)("p",null,"Imagine we have a bunch of enums which are either enabled or disabled."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Enum"),(0,l.kt)("th",{parentName:"tr",align:null},"Enabled?"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0000"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0001"),(0,l.kt)("td",{parentName:"tr",align:null},"no")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0002"),(0,l.kt)("td",{parentName:"tr",align:null},"no")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0003"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0004"),(0,l.kt)("td",{parentName:"tr",align:null},"no")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0005"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0006"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0007"),(0,l.kt)("td",{parentName:"tr",align:null},"no")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0008"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0009"),(0,l.kt)("td",{parentName:"tr",align:null},"no")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x000a"),(0,l.kt)("td",{parentName:"tr",align:null},"enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x000b"),(0,l.kt)("td",{parentName:"tr",align:null},"no")))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The enums are u16 (not u8) so that we are not limited to 256 colors.\nWe might never hit that limit, but it is not so unlikely that we shouldn't plan for it.")),(0,l.kt)("p",null,"The RGB array for this would look like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Example byte array\n[\n    enum_0000_R, enum_0000_G, enum_0000_B, // offset 0x0\n    enum_0003_R, enum_0003_G, enum_0003_B, // offset 0x3\n    enum_0005_R, enum_0005_G, enum_0005_B, // offset 0x6\n    enum_0006_R, enum_0006_G, enum_0006_B, // offset 0x9\n    enum_0008_R, enum_0008_G, enum_0008_B, // offset 0xc\n    enum_000a_R, enum_000a_G, enum_000a_B, // offset 0xf\n    ...\n]\n")),(0,l.kt)("p",null,"There are 2 things we need to be able to do given an enum:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Determine if it is enabled or not."),(0,l.kt)("li",{parentName:"ul"},"Find its index in the RGB data.")),(0,l.kt)("hr",null),(0,l.kt)("p",null,"For example, using the above data, we want to find the RGB index of enum 0x8."),(0,l.kt)("p",null,"(Let's assume we magically know that enum 0x8 is enabled for the time being)"),(0,l.kt)("p",null,"The solution is to count up how many of the enums 0 through 7 are enabled."),(0,l.kt)("p",null,"Since enums 0, 3, 5, and 6 are enabled (4 total), enum 8's RGB index is 4."),(0,l.kt)("p",null,"However, this way of determining the memory index is too slow and does not scale well."),(0,l.kt)("h2",{id:"check-enum-is-enabled"},"Check enum is enabled"),(0,l.kt)("p",null,"Let's go ahead and answer the question of how we can tell that an enum is enabled."),(0,l.kt)("p",null,"There is no reason to waste more than a single bit on this, so we only need one byte for every 8 enums (rounded up)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// pseudocode\nfunction isThisEnumEnabled(u16 myEnum) {\n    u16 tableIndex = myEnum >> 3;\n    u8 bitMask = 1 << (myEnum & 0x7);\n\n    // Assume we have a reference to the bitTable in the CLR0 chunk.\n    return (bitTable[tableIndex] & bitMask) !== 0;\n}\n")),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The above is slightly different than how it actually works in code\nWe have to adjust the input based on the minRecolorId in the header.\nAlways reference the code if you want to see exactly how something works.")),(0,l.kt)("h2",{id:"mapping-enum-to-rgb-index-quickly"},"Mapping enum to rgb index quickly"),(0,l.kt)("p",null,"If we are looking up enum 0x3e (62 decimal), instead of iterating through enums 0 through 0x3d and keeping track of how many are enabled, we can instead keep track of the cummulative results for every 8 enums."),(0,l.kt)("p",null,"For example:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"cummulativeSums Index"),(0,l.kt)("th",{parentName:"tr",align:null},"For Enums X to Y"),(0,l.kt)("th",{parentName:"tr",align:null},"Cummulative Count"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0000 to 0x0007"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0000")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x01"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0008 to 0x000f"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0003")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x02"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0010 to 0x0017"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0005")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x03"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0018 to 0x001f"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0005")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0020 to 0x0027"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0008")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x05"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0028 to 0x002f"),(0,l.kt)("td",{parentName:"tr",align:null},"0x000c")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x06"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0030 to 0x0037"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0010")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x07"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0038 to 0x003f"),(0,l.kt)("td",{parentName:"tr",align:null},"0x0012")))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The cummulative sum for index 0 will always be 0, so we will leave this off in the final structure.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"enumNumber >> 3.\n")),(0,l.kt)("p",null,"0x3e >> 3 gives 7."),(0,l.kt)("p",null,"We check the cummulative value at index 7.\nThe value for this is 0x12."),(0,l.kt)("p",null,"So then we fetch the value from the bitTable at offset 7.",(0,l.kt)("br",null),"\nLet's assume it like the following bits:"),(0,l.kt)("p",null,"0101 0110"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"From left to right, these bits are for enums 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a, 0x39, and 0x38.")),(0,l.kt)("p",null,"So now all we need to do is count the number of set bits to the right of our bit in question (which is bit 6 in this case), then add this value to the cummulative value (which we determined was 0x12)."),(0,l.kt)("p",null,"The number of set bits to the right of bit 6 is 3, so our RGB index for enum 0x3f is 0x15 (0x12 + 3)."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"So the final question to answer is how do we quickly count the number of bits to the right of bit 6."),(0,l.kt)("p",null,"Fortunately, this is a solved problem."),(0,l.kt)("p",null,"We can keep a small lookup table to quickly map from a bit pattern to the number of bits which are set."),(0,l.kt)("p",null,"For 8 bits, there are 256 possible patterns.\nIf we instead process each half of the 8 bits individually and add the results, we only need to handle 16 patterns:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"bit pattern"),(0,l.kt)("th",{parentName:"tr",align:null},"num bits set"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0000"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0001"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0010"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0011"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0100"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0101"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0110"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b0111"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1000"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1001"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1010"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1011"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1100"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1101"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1110"),(0,l.kt)("td",{parentName:"tr",align:null},"3")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0b1111"),(0,l.kt)("td",{parentName:"tr",align:null},"4")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// pseudocode, from https://stackoverflow.com/questions/9949935/calculate-number-of-bits-set-in-byte\nuint8_t NIBBLE_LOOKUP [16] =\n{\n    0, 1, 1, 2, 1, 2, 2, 3,\n    1, 2, 2, 3, 2, 3, 3, 4\n};\n\nuint8_t count_ones (uint8_t byte)\n{\n    return NIBBLE_LOOKUP[byte & 0x0F] + NIBBLE_LOOKUP[byte >> 4];\n}\n")),(0,l.kt)("p",null,"The above will return the total number of set bits in a byte, but we are only concerned with the bits to the right of a specific one, so we can adjust it to the following:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// pseudocode\nuint8_t NIBBLE_LOOKUP [16] =\n{\n    0, 1, 1, 2, 1, 2, 2, 3,\n    1, 2, 2, 3, 2, 3, 3, 4\n};\n\nuint8_t BITS_TO_RIGHT_MASK [8] =\n{\n    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f\n};\n\n// bitIndex is one of 0,1,2,3,4,5,6,7. 0 means the least significant bit.\n// Given a bit index, returns the number of bits which have a lower index and are set.\nint8_t countSetBitsToRight( uint8_t byte, uint8_t bitIndex )\n{\n    if ( bitIndex == 0 )\n    {\n        return 0;\n    }\n\n    uint8_t maskedByte = byte & BITS_TO_RIGHT_MASK[bitIndex];\n\n    uint8_t result = NIBBLE_LOOKUP[maskedByte & 0x0f];\n\n    if ( bitIndex >= 5 )\n    {\n        result += NIBBLE_LOOKUP[maskedByte >> 4];\n    }\n\n    return result;\n}\n")),(0,l.kt)("p",null,"So we now have all of the tools we need."),(0,l.kt)("p",null,"Let's talk about the entire CLR0 structure now."),(0,l.kt)("h2",{id:"clr0-structure"},"CLR0 structure"),(0,l.kt)("h3",{id:"header-1"},"Header"),(0,l.kt)("p",null,"Header is size 0x16 bytes."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Offset"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x00"),(0,l.kt)("td",{parentName:"tr",align:null},"char","[4]"),(0,l.kt)("td",{parentName:"tr",align:null},"magic"),(0,l.kt)("td",{parentName:"tr",align:null},'"CLR0"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x04"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"totalByteSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Total number of bytes for chunk (including header and padding at end).")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x08"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"reserved"),(0,l.kt)("td",{parentName:"tr",align:null},"Not currently used. Always 0x00.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x09"),(0,l.kt)("td",{parentName:"tr",align:null},"u8"),(0,l.kt)("td",{parentName:"tr",align:null},"bitTableOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to bitTable section relative to start of header.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0a"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"minRecolorId"),(0,l.kt)("td",{parentName:"tr",align:null},"Must be equal to the smallest enum which has data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0c"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"maxRecolorId"),(0,l.kt)("td",{parentName:"tr",align:null},"Must be equal to the largest enum which has data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x0e"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"cummulativeSumsOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to cummulativeSums section relative to start of header.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x10"),(0,l.kt)("td",{parentName:"tr",align:null},"u32"),(0,l.kt)("td",{parentName:"tr",align:null},"complexDataOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to complexData section relative to start of header.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"0x14"),(0,l.kt)("td",{parentName:"tr",align:null},"u16"),(0,l.kt)("td",{parentName:"tr",align:null},"basicDataOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Offset to basicData section relative to start of header.")))),(0,l.kt)("p",null,"Note that the sections of the CLR0 chunk are ordered as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"header"),(0,l.kt)("li",{parentName:"ul"},"bitTable"),(0,l.kt)("li",{parentName:"ul"},"cummulativeSums"),(0,l.kt)("li",{parentName:"ul"},"basicData"),(0,l.kt)("li",{parentName:"ul"},"complexData")),(0,l.kt)("p",null,"Notes on certain header properties:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"magic",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"CLR0 could change to CLR1 and so on if we ever needed an entire restructure of this chunk for some reason (though that doesn't seem likely)."))),(0,l.kt)("li",{parentName:"ul"},"maxEnum",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"This is used to future-proof.\nLet's assume at the current day we are using enums 0x0000 through 0x00ab.\nIf someone generates a seed today, its bitTable and cummulativeSums will be a certain size.\nIf someone then uses that seed with the newer randomizer 6 months later, that rando code might try to check \"should I recolor enum 0xcc?\"\nIf we didn't have a bounds on the maximum we should check, we would start reading bytes from outside the table and misinterpreting them.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Note that this value should be the largest enum which the player actually elected to recolor, not the largest one that could have been supported at the time the seed was generated.\nThe lower we can make this value, the smaller we can make both the bitTable and cummulativeSums sections.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"bitTable byte length should be ((maxEnum >> 3) + 1) rounded up to multiple of 2."),(0,l.kt)("li",{parentName:"ul"},"cummulativeSums section byte length should be (bitTable length - 1) ","*"," 2."))))))),(0,l.kt)("li",{parentName:"ul"},"bitTableOffset",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The header is only 0x16 bytes long, so we don't need more than a byte for bitTableOffset."),(0,l.kt)("li",{parentName:"ul"},"This value must be set to 0 if there is no data for any enums (meaning the CLR0 chunk is empty)."))),(0,l.kt)("li",{parentName:"ul"},"cummulativeSumsOffset\nThe max enum is 0xffff.\n(0xffff >> 3) is 0x1fff which is the maximum index of the bitTable.\nSo the max bitTable length is one more than that, or 0x2000.\nAdding the 0x16 from the bitTableOffset, the largest value we could have for this is 0x2016, so u16 is enough for this field."),(0,l.kt)("li",{parentName:"ul"},"basicData",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The max enum is 0xffff.\n(0xffff >> 3) is 0x1fff which is the maximum index of the cummulativeSums section.\nSo the max cummulativeSums length is one more than that, or 0x2000.\nSince each entry is a u16 (2 bytes), the maximum byte length of the cummulativeSums section is 0x4000.\nAdding this to the maximum cummulativeSumsOffset which is 0x2016, the maximum possible basicDataOffset value is 0x6016.\nSo a u16 is enough for basicData."),(0,l.kt)("li",{parentName:"ul"},"Note that the basicData should immediately follow the cummulativeSums section.")))),(0,l.kt)("h3",{id:"bittable"},"bitTable"),(0,l.kt)("p",null,"bitTable section is an array of bytes which comes directly after the header."),(0,l.kt)("p",null,"It contains one byte for every 8 recolorIds."),(0,l.kt)("p",null,"If no recolorIds are enabled, the offset to the bitTable in the header must be 0."),(0,l.kt)("h3",{id:"cummulativesums"},"cummulativeSums"),(0,l.kt)("p",null,"cummulativeSums section is an array of u16 which comes directly after the bitTable section.\nWe leave off the entry for index 0 of the bitTable since it would always be 0x0000."),(0,l.kt)("p",null,"If this section is empty, the offset to it in the header should be 0."),(0,l.kt)("h3",{id:"basicdata"},"basicData"),(0,l.kt)("p",null,"The basicData section comes directly after the cummulativeSums section, and it is an array of words."),(0,l.kt)("p",null,"For example, an entry might be:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"00 63 82 A0")),(0,l.kt)("p",null,"The first byte is an enum called the ",(0,l.kt)("inlineCode",{parentName:"p"},"RecolorType"),"."),(0,l.kt)("p",null,"In this case, 0x00 means the next 3 bytes (63 82 A0) are an rgb value (63 is R, 82 is G ,and A0 is B)."),(0,l.kt)("p",null,"The last 3 bytes could have a different meaning depending on the first byte (the enum).\nFor example, if the first byte was 0x01 meaning RgbArray, then the remaining 3 bytes would actually be an offset in the complexData section, and the RGB array would be stored in the complexData section."),(0,l.kt)("h3",{id:"complexdata"},"complexData"),(0,l.kt)("p",null,"The complexData section could very well be empty (in which case the offset to it in the header should be 0)."),(0,l.kt)("p",null,"But assuming it is not empty, it is just an array of bytes with no structure."),(0,l.kt)("p",null,"A basicData entry which makes use of it will point to an offset in the complexData section.\nThe bytes at that location in the complexData will be interpreted according to the enum that was in the basicData."),(0,l.kt)("p",null,"For example, recolorType 0x01 is an RgbArray."),(0,l.kt)("p",null,"Let's look at some example data:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"43 4C 52 30 00 00 00 38 00 16 00 00 00 07 00 00  CLR0...8........\n00 00 00 1F 00 17 81 00 63 82 A0 01 00 00 00 08  ........c, .....\nFF FF FF FF A0 FF FF FF 40 00 E8 7B 00 F3 FF 00  .... ...@..{....\nAA FF 60 78 FF 00 00 00 00 00 00 00 00 00 00 00  ..`x............\n")),(0,l.kt)("p",null,"From offset 0x14 of the header, we get that the basicData offset is 0x0017."),(0,l.kt)("p",null,"The 2 basicData entries are as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"00 63 82 A0"),(0,l.kt)("li",{parentName:"ul"},"01 00 00 00")),(0,l.kt)("p",null,"Looking at the 2nd entry, we see the RecolorType is 0x01 which is RgbArray.\nThis means the last 3 bytes (in this case, 00 00 00) is an offset in the complexData section."),(0,l.kt)("p",null,"We can get the offset to the complexData section from offset 0x10 of the header."),(0,l.kt)("p",null,"In this case, the complexData section is at offset 0x1F."),(0,l.kt)("p",null,"So the data we are looking at starts with ",(0,l.kt)("inlineCode",{parentName:"p"},"08 FF FF FF FF A0 ..."),"."),(0,l.kt)("p",null,"The structure of the data is entirely dependent on the recolorType, but in the case of RgbArray, the first byte is the array length, and it is followed by 3 byte RGB array entries."),(0,l.kt)("p",null,"So in this case:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"length",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"8"))),(0,l.kt)("li",{parentName:"ul"},"entries:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"FF FF FF"),(0,l.kt)("li",{parentName:"ul"},"FF A0 FF"),(0,l.kt)("li",{parentName:"ul"},"FF FF 40"),(0,l.kt)("li",{parentName:"ul"},"00 E8 7B"),(0,l.kt)("li",{parentName:"ul"},"00 F3 FF"),(0,l.kt)("li",{parentName:"ul"},"00 AA FF"),(0,l.kt)("li",{parentName:"ul"},"60 78 FF"),(0,l.kt)("li",{parentName:"ul"},"00 00 00")))),(0,l.kt)("p",null,"The above data in this example are the colors for the rainbow hearts."),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The rainbow hearts are always displayed in the game with an ABCABCABC pattern.\nIf you wanted a ping-pong ABCBABCBA pattern, you could probably update the first byte to be:\n0x80 mask gives 0 or 1 to indicate pattern, and the 0x7F mask gives the array length.")),(0,l.kt)("h2",{id:"other-notes"},"Other notes"),(0,l.kt)("h3",{id:"future-splitting-up-of-recoloring"},"Future splitting up of recoloring"),(0,l.kt)("p",null,"Let's assume that the tunic recoloring is enum 0x0000."),(0,l.kt)("p",null,"It is possible that in the future, we will want people to be able to recolor the hat and body separately."),(0,l.kt)("p",null,"In that case, we can add 2 new enums (let's say 0x00cd and 0x00ce)."),(0,l.kt)("p",null,"Then in the rando code, we can check if either of these is enabled.",(0,l.kt)("br",null),"\nIf either is enabled, we will use the values from those enums and ignore enum 0x0000."),(0,l.kt)("p",null,"We still want to support 0x0000 for backwards compatibility if neither of the new enums are enabled but 0x0000 is enabled."))}d.isMDXComponent=!0}}]);