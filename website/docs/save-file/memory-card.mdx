# Memory Card

import Link from '@docusaurus/Link';

Here we discuss the Twilight Princess save data structure on the memory card at a high level.
If you are interested in things like rupees and poe souls, please see the <Link to="/docs/save-file/quest-log/introduction">Quest Log</Link>.

## Blocks Overview

Memory card data consists of "blocks" which are each 0x2000 bytes. The first 5 blocks of a memory card are allotted to manage the filesystem.

| Offset | Size   | Description                   |
| ------ | ------ | ----------------------------- |
| 0x0000 | 0x2000 | Header                        |
| 0x2000 | 0x2000 | Directory                     |
| 0x4000 | 0x2000 | Directory (backup)            |
| 0x6000 | 0x2000 | Block Allocation Map          |
| 0x8000 | 0x2000 | Block Allocation Map (backup) |

A game's save data will consist of a certain number of blocks which are located somewhere after the first 5 filesystem blocks.

For example, TP's save data is 4 blocks long, so these blocks might be located at offsets 0xa000, 0xc000, 0xe000, and 0x10000 on a fresh memory card, but they could also be at 0x22000, 0x24000, 0x26000, and 0x28000.

The blocks do not necessarily have to be contiguous, but in practice they usually are, and it may be easier to think of them that way.

:::tip

The official memory card types are Memory Card 59, Memory Card 251, and Memory Card 1019. Do you notice a pattern?<br/>
64 - 5 is 59, 256 - 5 is 251, and 1024 - 5 is 1019.

:::

## DirectoryEntry Overview

The special Directory filesystem block contains an array of Directory Entries which are each 0x40 bytes long.

In addition to its 4 blocks (0x8000 bytes), TP also specifies some `(all?)` of the data which is written to its DirectoryEntry. We will talk more about the DirectoryEntry after covering the Block data.

## Twilight Princess Save Data Overview

| Size   | Description    |
| ------ | -------------- |
| 0x40   | DirectoryEntry |
| 0x8000 | 4 Blocks       |

You can think of the above as the TP save data which is on the memory card.

:::tip

A Twilight Princess `GCI` file is exactly these two things back-to-back as shown above.

:::

## Blocks

TP save data has 4 blocks:

| BlockNo | Description             |
| ------: | ----------------------- |
|       1 | Header                  |
|       2 | Header (continued)      |
|       3 | Quest Log Data          |
|       4 | Quest Log Data (backup) |

### Header Blocks

The Header spills over into the second block, so those two blocks will be treated as a chunk of 0x4000 bytes for discussion purposes. Remember that the two blocks may not actually be back-to-back on the memory card.

| Offset |   Size | Description            |
| -----: | -----: | ---------------------- |
| 0x0000 |  0xc00 | Banner pixel data      |
| 0x0c00 |  0x200 | Banner palette data    |
| 0x0e00 |  0x400 | Icon pixel data        |
| 0x1200 |  0x400 | Icon pixel data (copy) |
| 0x1600 |  0x400 | Icon pixel data (copy) |
| 0x1a00 |  0x400 | Icon pixel data (copy) |
| 0x1e00 |  0x400 | Icon pixel data (copy) |
| 0x2200 |  0x200 | Icon palette data      |
| 0x2400 |   0x20 | Comment 1              |
| 0x2420 |   0x20 | Comment 2              |
| 0x2440 | 0x1bc0 | Unused/garbage         |

#### Banner

<img
  src={require('@site/static/img/savefile/zelda2_gc_banner.bti.png').default}
  alt="zelda2_gc_banner.bti"
/>

A GameCube game's (optional) banner always has dimensions 0x60 by 0x20 pixels (96 x 32 decimal).

TP's banner is in CI8 format which means it uses one byte per pixel (0x60 \* 0x20 is 0xc00).

CI8 format also means that the 0x200 bytes following the 0xc00 pixel data will be the palette data. Each palette entry is 2 bytes long, meaning a CI8 banner may use up to 0x100 unique palette entries. TP's banner actually only makes use of the first 0x160 bytes of the palette data space.

#### Icons

<img
  src={require('@site/static/img/savefile/zelda2_gc_icon.bti.png').default}
  alt="zelda2_gc_banner.bti"
/>

A GameCube game's (optional) icon always has dimensions 0x20 by 0x20 pixels (32 x 32 decimal). It may be composed of multiple icons which it animates between.

TP specifies in its DirectoryEntry that each icon is in CI8 format with a shared color palette following all of the pixel data, and it also specifies that it has 5 icons.

As with the banner, CI8 format means that each pixel of an icon takes one byte. Since each icon has dimensions 0x20 by 0x20, each icon is 0x400 bytes long.

Also as with the banner, the palette data must fit in the 0x200 bytes following the end of the pixel data. For its icons, TP makes use of the full 0x200 bytes.

:::info

The zelda2_gc_banner.bti and zelda2_gc_icon.bti are located in the Yaz0-encoded `/res/CardIcon/cardicon.arc`. "Card" here is short for Memory Card.

:::

#### Comments 1 and 2

Each comment is a null-terminated string which can use up to 0x20 bytes.

These bytes (in addition to the banner and icon) are visible when managing memory card data on your GameCube.

For the US GameCube version of TP, the first comment is always "Zelda: Twilight Princess", and the second comment is something like "6/4 Save Data" (which is Month/Day).

#### Unused/Garbage

The last 0x1bc0 of Block 2 is not used for anything.

If you inspect memory card data for TP in a hex editor, you may see what appears to be quest log data in this space. This is a side-effect of the game only using `memset` to zero out the buffer it writes blocks to (before they are copied to the memory card) before writing the Header there in certain cases. If you edit any of these 0x1bc0 bytes in your memory card before loading up the game, you will not see any effect.

Other bytes which may contain garbage in the first two TP Blocks are as follows:

- The last 0x40 bytes of the banner's palette data (starting at offset 0xd60).
- In each Comment (offsets 0x2400 and 0x2420), the bytes which follow the null termination character of the Comment.

### Quest Log Blocks

Blocks 3 contains the data for the 3 Quest Logs. Block 4 is a backup copy of Block 3, so its data should match Block 3's exactly (assuming nothing unexpected happened during any memory card writes).

The Quest Log Block structure is as follows:

| Offset |  Size | Description       |
| -----: | ----: | ----------------- |
| 0x0000 |   0x8 | 00000000 00000006 |
| 0x0008 | 0xa94 | Quest Log 1 Data  |
| 0x0a9c | 0xa94 | Quest Log 2 Data  |
| 0x1530 | 0xa94 | Quest Log 3 Data  |
| 0x1fc4 |  0x34 | Unused/garbage    |
| 0x1ff8 |   0x8 | Checksum          |

#### First 8 Bytes

The first eight bytes are always set to:<br/>
00 00 00 00<span style={{display:'inline-block',height:1,width:16}}></span>00 00 00 06

My guess is that this is a version number for the quest log structure which was incremented during development, and they ended on 6.

#### Quest Log Data

Each Quest Log's data is the same structure. The structure is rather complex, so it will be covered on a different page.

#### Unused/Garbage

- ahsdfiosdhfi

Note that each of the 0xa94 Quest Log Data sections contain unused/garbage bytes as well, but that will be covered on a separate page.

#### Checksum

- asdhfos

## DirectoryEntry

These 0x40 bytes contain metadata about the Twilight Princess save data on the memory card. They live in a special Directory block, hence the name. These are also the first 0x40 bytes of a GCI file.

| Offset | Type     | Description         | Status (temp column) |
| -----: | -------- | ------------------- | -------------------- |
|   0x00 | u8[4]    | gameCode            |                      |
|   0x04 | u8[2]    | publisherCode       |                      |
|   0x06 | u8       | padding_06          |                      |
|   0x07 | u8       | bannerAndIconFlags  |                      |
|   0x08 | u8[0x20] | filename            |                      |
|   0x28 | u32      | lastModified        | done?                |
|   0x2c | u32      | imageDataOffset     |                      |
|   0x30 | u16      | iconFormats         |                      |
|   0x32 | u16      | iconAnimationSpeeds |                      |
|   0x34 | u8       | permissions         |                      |
|   0x35 | u8       | copyCounter         |                      |
|   0x36 | u16      | firstBlockIndex     |                      |
|   0x38 | u16      | numBlocks           |                      |
|   0x3a | u8[2]    | padding_38          |                      |
|   0x3c | u32      | commentsOffset      |                      |

### gameCode

gameCode will be one of the following depending on the game region:

| gameCode | Region                                         |
| -------- | ---------------------------------------------- |
| GZ2E     | USA                                            |
| GZ2J     | Japan                                          |
| GZ2P     | Europe and other PAL regions such as Australia |

G is for Gamecube, Z2 is the title code for Twilight Princess, and the last character is dependent on the region as shown above.<br/>
Read more about it here: [GameIDs - Dolphin Emulator Wiki](https://wiki.dolphin-emu.org/index.php?title=GameIDs)

These bytes are available at address 0x80000000 which is where they are copied from when creating the DirectoryEntry.

### publisherCode

publisherCode will always be "01" (0x3031) which is the publisherCode for Nintendo.

These bytes are available at address 0x80000004 which is where they are copied from when creating the DirectoryEntry.

### padding_06

Unused byte which will always be 0xff under normal conditions.<br/>
See <Link to="#why-0xff">Why is the padding 0xff?</Link> for more info.

### bannerAndIconFlags

sdhafioashdfo

### filename

asdhfidohsf

### lastModified

The last time this DirectoryEntry was modified represented by the number of seconds since 2000/01/01 00:00.

----- Better phrasing. True about directory entry, but mainly is referring to the file (which is made up of the 4 blocks).

This value is calculated by dividing the OSTicks which are returned from `OSGetTime` by 40,500,000 (OSTicks per second) then taking the lower 32 bits of the 64 bit result.

// ADD CONVERTER COMPONENT HERE (takes hex seconds value and outputs info)

### imageDataOffset

// ashdfio

### iconFormats

// ashdfio

### iconAnimationSpeeds

// ashdfio

### permissions

// ashdfio

### copyCounter

// ashdfio

### firstBlockIndex

// ashdfio

### numBlocks

// ashdfio

### padding_38

Two unused bytes which will both be 0xff under normal conditions.<br/>
See <Link to="#why-0xff">Why is the padding 0xff?</Link> for more info.

### commentsOffset

// ashdfio

## DirectoryEntry Follow-up

### Why is the padding 0xff? {#why-0xff}

Short version:

- The padding bytes are set to 0xff when the memory card is formatted.
- They are never changed after that point.

Longer version:

When a memory card is formatted, its Directory blocks are mostly filled with 0xff:

| Offset | Size   | Description   |
| ------ | ------ | ------------- |
| 0x0000 | 0x1ffa | 0xff bytes    |
| 0x1ffa | 0x0002 | updateCounter |
| 0x1ffc | 0x0002 | checksum1     |
| 0x1ffe | 0x0002 | checksum2     |

That is to say, all bytes are 0xff except the last 6.

Shortly after starting up the game (before the WARNING-HEALTH AND SAFETY screen shows), the two Directory blocks are read from the memory card into RAM. When you tell TP to create save data on the memory card, it overwrites a portion of this RAM with its DirectoryEntry data which is then copied back to the memory card.

Within the 0x40 bytes in RAM into which the TP DirectoryEntry is written, the padding bytes are never overwritten since there is nothing which needs to be stored there. This means they maintain whatever value they had on the memory card. This value is expected to always be 0xff since the only time these bytes are modified is when the memory card is formatted.

However, you can manually manipulate the memory card beforehand so that these bytes are a different value in order to see they they will not be changed. Below is a memory card raw image you can download which has had its first DirectoryEntry slot filled with 0xaa (other than the first byte which needs to be 0xff):

<p>
  <a target="_blank" href="/saveData/raw/mem59_dirEntryAaBytes.USA.raw">
    Download mem59_dirEntryAaBytes.USA.raw
  </a>
</p>

If you open TP with that data written to your memory card then say you want to create TP save data on the memory card, you will see that the padding bytes will never change from 0xaa.

Note that this applies to the padding at offset 0x06 and at offset 0x3a.

### Thoughts on lastModified

- A time of 2136/02/07 06:28:15 would give 0xffffffff seconds after 2000/01/01 00:00. I think the only way to get your Gamecube's date this high is to set it to 2099 and wait 30+ years. Even then, it is possible that the OSTick count returned from OSGetTime is based on a fixed clock and is not adjusted with any changes you make in the IPL (this could be tested). In any case, the clock battery would probably die before this became an issue.
- The 64 bit OSTicks count wouldn't get its sign bit set until around Sep 18, 9216 at 15:12:36.908044, so this is not worth thinking about.

### CheckCardStat

When restoring data from the memory card, one of the things TP does is run a function called `m_Do_MemCardRWmng::mDoMemCdRWm_CheckCardStat`. This runs a few checks on the loaded DirectoryEntry data. If any of these fail it is considered a fatal error, and the game will act as if you don't have any save data on the memory card (meaning it will ask you to create save data).

Here are the checks which must always pass:

- imageDataOffset is 0x00000000
- commentsOffset is 0x00002400
- imageAndBannerFlags: the least signficant 3 bits are 0b101
- iconFormats is 0x0155
- iconAnimationSpeeds is 0x0155

## Other Formats

### GCIs

A Twilight Princess GCI file is 0x8040 bytes long and is simply the DirectoryEntry (0x40 bytes) followed by the 4 Blocks (0x8000 bytes).

Think of a GCI as a portable version of a game's data on a memory card.

- ashdifoh Other info about DirectoryEntry things that don't matter in the context of a GCI file (if any).

### Wii

- TBD

### Nvidia Shield

The Shield's save data is 0x4000 bytes long. It is composed of Blocks 3 and 4, which are the Quest Log data block and its backup.

It does not need the DirectoryEntry or Header blocks since those are specifically designed to work with the GameCube.

## Closing Thoughts

Here we only covered as much as was necessary to talk about the memory card in the context of TP. If you would like to read more about the structure of data on the memory card, check out these links:

- <Link to="http://hitmen.c02.at/files/yagcd/yagcd/chap12.html">
    Yet Another Gamecube Documentation (YAGCD) Ch. 12
  </Link>
- <Link to="https://github.com/dolphin-emu/dolphin/blob/5513d5f4f732fb1e436765ab87e7d60ba02b1ad6/Source/Core/Core/HW/GCMemcard/GCMemcard.h">
    GCMemcard.h in Dolphin
  </Link>
- <Link to="https://github.com/devkitPro/libogc/blob/master/gc/ogc/card.h">
    libogc/card.h
  </Link>

Note that YAGCD is wrong about byte 0x07 of the DirectoryEntry, so be sure to check the Dolphin source code for that one.

### Why 5 identical icons?

----- Can test with 1 icon and make an example memory card raw image for this. Should work the same on the IPL since that is what the header blocks are for anyway.

You might have noticed that 87% of block 2 is unused and that we could easily fit the Header on a single block if we did not store 5 copies of the same icon data.

Unfortunately, I do not have an answer for why this is the case.

My best guess is that they were planning to use an animated icon but ran out of time or decided against it, and they never went back to update the code. Evidence in support of this is that they do go out of their way to set the IconAnimation bit in the DirectoryEntry to 1 (which indicates to use a ping-pong pattern rather than a loop).

But I am open to other interpretations. Let me know if you think there is a better explanation.

### Default selection on the file select screen?

You might expect there to be some metadata outside of the quest logs which keeps track of which one to default to on the file selection screen, but this is not the case.

The default is picked this way:

- From the set which includes Quest Log 1 and any other Quest Logs which pass their checksum test, pick the QuestLog which is the latest down to the seconds level.
- In the case of a tie, Quest Log 1 has the highest priority and Quest Log 3 has the lowest priority.

:::info

Quest Logs which fail their checksum test say "This Quest Log is corrupted."

:::

## Naming

### DirectoryEntry

------- Mention cardStat stuff. cardStat is a more verbose version of the directory entry data I think.

This DirectoryEntry data is written as an entry on the Directory Block, hence the name DirectoryEntry.
We are using this name for a couple of reasons:

- Variations of "directory entry" (such as 'DEntry' and '\_card_direntry') are what you will see in other places.
- We can afford to be more descriptive with the name since this is only documentation and not source code.

Based on the OS function names `CARDGetStatus` and `CARDSetStatus` which handle reading and writing this data, it is possible that this data could also be called something like "Status". TP itself has funtions `m_Do_MemCardRWmng::mDoMemCdRWm_SetCardStat` and `m_Do_MemCardRWmng::mDoMemCdRWm_CheckCardStat` which call the OS functions internally. They bring to mind the Linux command `stat` which is said to "display file or file system status". The data in this 0x40 byte chunk is essentially what you would see if you could run that command on a memory card (metadata about some data stored in the filesystem).

The term "Directory Block" is supported by the OS function `card::__CARDGetDirBlock`.

## References

- <Link to="http://hitmen.c02.at/files/yagcd/yagcd/chap12.html">
    Yet Another Gamecube Documentation (YAGCD) Ch. 12
  </Link>
- <Link to="https://github.com/dolphin-emu/dolphin/blob/5513d5f4f732fb1e436765ab87e7d60ba02b1ad6/Source/Core/Core/HW/GCMemcard/GCMemcard.h">
    GCMemcard.h in Dolphin
  </Link>
- <Link to="https://github.com/devkitPro/libogc/blob/master/gc/ogc/card.h">
    libogc/card.h
  </Link>
- <Link to="https://wiki.dolphin-emu.org/index.php?title=GameIDs">
    GameIDs - Dolphin Emulator Wiki
  </Link>
